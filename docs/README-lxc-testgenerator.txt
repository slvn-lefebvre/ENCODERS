Last modified: Sam Wood, 4/10/13

=====
TEST GENERATOR:
=====

The TESTGENERATOR generates directories containing testcases that are 
compatibile with the TESTRUNNER. A user specifies a json file containing 
multiple test specification (i.e. mobility parameters, application parameters, 
number of nodes, etc) in json format.

Relevant files & directories: 

    - ../studies/framework/lxc-testgenerator/ - Directory containing all the test generator files.
        - test_generator.py : the test generator, which expects a test
                              specification file, in json format.
    - ../studies/framework/lxc-testgenerator/ApplicationModules/ - Directory containing the supported
        applications. Currently we only support "custom" and "uniform". 
        Applications are executed on each haggle daemon, and specify the
        publish/subscribe order.
    - ../studies/framework/lxc-testgenerator/MobilityModules/ - Directory containing the supported
        mobility models. Currently we support "rwp" (random way point) 
        using the bonn motion tool. This tool must be installed and available
        via "bm" in the PATH. 
    
An example run:

cd TestGenerator && python testgenerator.py sample_test_spec.json

which will generate tests ready for execution in the "Testsuite/" directory.

Please read: http://json.org for a description of the json format. (NOTE: we
augment the language with several meta-keywords that are interperted
specially.)


Supported Parameters:
----

The spec file expects a number of tests to be specified in a json formatted
list of test objects: [ {..}, {...}, ...]

The supported top level parameters for a test object are as follows:

format:
"parameter" : "example value" <- description

"test_name" : "xxxx" <- the test name that will be used by the testrunner.
it is best of this name is unique as possible (see '%%pretty%%' discussion
later).

"test_output_path" : "/path" <- the path where the test generator will place
the test. If this is relative, then it is intepreted as relative to the
json spec.

"result_output_path" : "/path" <- the path where the testrunner will place
the test output upon test completion. If relative, then this path will be
interpreted to be relative to the json spec. 

"test_template" : "/path" <- the path containing the test template used
by the test generator to generate the test. If relative, then this path
will be interpreted to be relative to the json spec. This parameter should
almost always be set to "./TestTemplate/". If not set, the test framework
will set an appropriate default.

"num_nodes" : "10" <- the number of nodes in the test. The nodes will be
named n1...n10.

"duration" : "600" <- the number of seconds the test will take. In practice,
test generator will add some padding to this in order to give the haggle
daemon's time to start and shutdown. 

"warmup" : "10" <- the number of seconds to wait before launching the haggle
daemons. The mobility will start immediately. 

"seed"   : "1" <- a generic seed parameter that will be passed to the 
underlying application generator and mobility generator (it can be overridden).

"area_height" : "400" <- the area height in meters of the test (we use
a scale factor of 1:1 for meters to pixels in order to simplify our lives, 
pixels is not meaningful measurement of distance).

"area_width" : "400" <- the area width in meters of the test.

"files" : [ 
    [ "/tmp/filepath", filesize_kb] ...
] <- a list of files that the testgenerator should generate, where
/tmp/filename is the path of the file, and filesize_kb is the file size
in KB. This is useful by applications which can reference this path. These
files will be created and the beginning of the test, and removed at the end 
of the test.

PRETTY DIGRESSION:
To uniquely generate meaningful test names, some parameters allow the user
to specify a "pretty_name" : "some name" parameter. Anywhere in the test,
the user may specify the reserved keyword "%%pretty%%" which will use the
specified pretty names to generate a unique test name. All occurences of
"%%pretty%%" will be replaced by this unique test name. 
---

"pretty_settings" : {
    "verbosity" : 1,
    "max_len" : 100,
    "enable_mobility" : "true",
    "enable_app" : "true",
    "enable_macphy" : "true"
} <- specify how the autogenerated "%%pretty%%" keyword will be replaced 
across the test.
"verbosity" <- the verbosity of the string, where a higher number is more
verbose.
"max_len" <- the maximum number of characters in the "%%pretty%%" string.
"enable_mobility" <- true/false to specify whether to include the 
autogenerated pretty string from the mobility module into "%%pretty%%".
"enable_app" <-  true/false to specify whether to include the 
autogenerated pretty string from the application module into "%%pretty%%".
"enable_macphy" <-  true/false to specify whether to include the 
autogenerated pretty string from the macphy module into "%%pretty%%".

"config" : {
    "path" : "/path/for/default/config.xml",
    "pretty_name" : "a name to be used with the %%pretty%% parameter",
    "per_node_configs" : {
        "n1" : "/path/for/n1/config.xml"
        ...
    },
    "replace_dict" : {
        "%%debug" : "true"
    },
    "security_cfg" : {
        ...
    }
} <- specify configuration files for the nodes in the test. These configuration
files will be automatically copied to the ~/.Haggle/config.xml for each node.
    "path" <- the path for the default configuration for all nodes. If
relative, then it will be interpreted as relative to the test_spec.json.
    "per_node_configs" <- [optional] dictionary specifying paths for 
particular nodes (overrides the default path).
    "replace_dict" <- [optional] dictionary which specifies strings to be 
replaced in the configuation files. For example, if config.xml has the string
"%%debug%%" then it will be replaced by the string "true".
    "security_cfg" <- [optional] dictionary which specifies the security
configuration for this particular test. If present this will over-ride
the default "security_cfg" section. See the SECURITY section below for details.

"custom_validate" : {
    "path" : "/path/to/validate_shell_script.sh",
    "replace_dict" {
        "%%another_replace_dictionary%%" : 1
    }
} <- An [optiona] validation shell script that will take as input the apps_output
file generated by testrunner, in order to confirm whether or not the test
passed (a non zero status code indicates a test failure). 
"path" <- The path to the validation shell script. If relative, then it
will be intepreted as relative to the json spec.
"replace_dict" <- An [optional] dictionary specfiying strings to replace
within the validate shell script (they dictionary key will be replaced
by the specifiy value, or %%another_replace_dictionary%% by 1 in this case.

=====
MOBILITY:

We support a variety of mobility models, mainly through the BonnMotion
mobility generator. We convert ns2 scen files so that they are compatible 
with CORE (CORE expects a more strict definition of the scen format than
ns2). 

The python code for the mobility models can be found:
TestGenerator/MobilityModules/

"mobility_cfg"       : {
    "name" : "MODEL_TYPE",
    "pretty_name" : "PRETTY_MODEL_NAME",
    "parameters" : {
        ...
    }


'name' <- specifies the mobiltiy type.
'pretty_name' <- parameter specifies what name will be included in the
'%%pretty%%' string.
'parameters' <- a dictionary of mobility parameters that's passed to the 
underlying mobility model. The 'seed', 'duration' and 'num_nodes' is 
automatically included in this dictionary.

Supported models:
----

"scen" : An ns2 scen file. 

Example: 

    "mobility_cfg"       : {
        "name" : "scen",
        "pretty_name" : "prettygrid",
        "parameters" : {
            "scen_file" : "./sample_scen.scen"
        }
    }

"scen_file" <- the path to the external scen file. If relative, then it
will be interpreted as relative to the json spec.

----

"static" : A static topology created in CORE (.imn) format.

Example:

    "mobility_cfg"       : {
        "name" : "static",
        "parameters" : {
            "static_file" : "./sample_static.imn"
        }

"static_file" <- the path to the external imn file. If relative, then it
will be interpreted as relative to the json spec.

----

"grid" : A RxC grid, where the nodes are evenly spaced out according to
the width/height of the scenario. "chain" is simply a macro for 
a Nx1 grid (without the need to specify for rows/columns) .  

Example:

    "mobility_cfg"       : {
        "name" : "grid",
        "parameters" : {
            "rows"    : 4,
            "cols"    : 3,
            "max_spacing_m" : 10
        }
    }
"rows" <- the number of rows
"cols" <- the number of columns
"max_spacing_m" <- [optional] maximum spacing between nodes (in meters).

----

"clique" : All of the nodes within contact (on top of each other). 

Example:

    "mobility_cfg"       : {
        "name" : "clique"
    }

----

"rwp" : The random waypoint mobility model (generated by BonnMotion). 

Example:

    "mobility_cfg"       : {
        "name" : "rwp",
        "parameters" : {
            "mobility_delay_s"   : 10,
            "rwp_v_min"          : 1,
            "rwp_v_max"          : 7,
            "rwp_p_max"          : 5
        }
    }


"mobility_delay_s" <- the delay in seconds to insert at the beginning of the 
test before starting the mobility. 

"rwp_v_min" <- the minimum velocity parameter to random waypoint (m/s).

"rwp_v_max" <- the maximum velocity parameter to random waypoint (m/s).

"rwp_p_max" <- the maximum pause time (in seconds) parameter to random waypoint.

The waypoint is selected uniformly at random from the area, and nodes travel 
to the waypoint at a velocity picked uniformly from [rwp_v_min, rwp_v_max].
Once they reach the waypoint, they pause for a duration [0, rwp_p_max], and
select a new waypoint uniformly at random (and the process repeats).

---

"nomadic" : The nomadic community group mobility model (generated by 
BonnMotion).

Example:

    "mobility_cfg"       : {
        "name" : "nomadic",
        "parameters" : {
            "v_min"             : 10,
            "v_max"             : 15,
            "p_max"             : 5,
            "avg_group_size"    : 4,
            "max_center_dist_m" : 150,
            "std_group_size"    : 1,
            "ref_max_pause_s"   : 6
        }

"v_min" <- the minimum velocity (in m/s) for each node.
"v_max" <- the maximum velocity (in m/s) for each node.
"p_max" <- the maximum pause time (s) for each node.
"avg_group_size" <- the average size of the clusters.
"std_group_size" <- the standard deviation of the size of the clusters.
"max_center_dist_m" <- the maximum distance from the cluster reference that
the nodes will travel. 
"max_ref_pause_s" <- the maximum pause time for the reference point (s). 

Nodes travel in groups with random velocities (similar to RWP) following
a cluster way point. 

---

"circle" : Allows an individual node to travel around in a circle
(or oval). This is useful to model a UAV.

Example:

{
    "nodes" : [5],
    "name" :  "circle",
    "offset_x" : 50,
    "offset_y" : 100,
    "parameters" : {
        "area_width" : 500,
        "area_height" : 400,
        "velocity" : 50,
        "circle_density" : 24
    }
}

The circle or oval will be within the rectangular area defined
by the area width and height (the offsets are explained below).

"velocity" <- how fast the node should move in a circle.

"circle_density" <- the number of way points in the circle (it is
discretized). 

---

"overlay" : A meta-mobility model that allows you to compose mulitple different
mobility models into one! We use a tiling approach, where mobilities operate
within a specified sub-area "tile", offset from the main area.

Example:

    "mobility_cfg"       : {
       "name" : "overlay",
        "parameters": {
            "mobilities" : [
                {
                    "nodes" : [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12],
                    "name" :  "grid",
                    "offset_x" : 0,
                    "offset_y" : 0,
                    "parameters" : {
                        "area_width" : 300,
                        "area_height" : 300,
                        "rows" : 4,
                        "cols" : 3
                    }
                },
                {
                    "nodes" : [13, 14, 15, 16, 17, 18, 19, 20, 21, 22],
                    "name" :  "rwp",
                    "parameters" : {
                        "add_to_parent_seed" : 1,
                        "rwp_v_min" : 1,
                        "rwp_v_max" : 7,
                        "rwp_p_max" : 5
                    }
                }
            ]
        }

In this example, nodes n1-12 will be in a 4x3 grid, and nodes n13-22 will
do random waypoint. 

"mobilities" <- Specify an array of multiple mobility models to super-impose. 
The "parameters" and "name" specify the model name, and the parameters to
pass to the constituent model. 
"nodes" <- Specify which nodes the model is applicable for. 
"offset_x" <- The distance in meters from the x-axis that the mobility 
should be placed.
"offset_y" <- The distance in meters from the y-axis that the mobility 
should be placed.

The parameters will be passed to the underlying mobility model, overriding
any existing parameters that are set. For example using "area_width" and
"area_height", one can modify the tile size for the sub-model. 

An important parameter for mobility models is specifying unique seeds. We
need a mechanism to allow multiple instances of a mobility model to use
different seeds. To this end we have the "add_to_parent_seed" parameter
which will use the default "seed" and add a constant to it, in order
to generate a new seed.

====
APPLICATION:

We support a variety of applications to generate traffic in our tests. 
All of the application models are converted to a script which specifies 
the per node publications and subscriptions which are executed by haggletest. 
For each node, all of the subscriptions occcur as a separate haggletest 
application, and all of the publications occur within a single haggletest
application (to reduce the number of application nodes that are generated).

The python code for applications is in:
TestGenerator/ApplicationModules/

----

"custom" : specify the individual publish subscriptions for each node.

Example:

"application_cfg"    : {
        "name" : "custom",
        "pretty_name" : "pretty_app",
        "parameters" : {
            "script" : [
                {
                    "node_num" : 1,
                    "time"     : 1,
                    "type"     : "pub",
                    "file"     : "/tmp/10KB",
                    "attributes" : { "key" : "value" }
                }, 
                {
                    "node_num" : 2,
                    "time"     : 0,
                    "type"     : "sub",
                    "print_output" : "true",
                    "duration" : 7,
                    "attributes" : { "key" : "value" }
                },
                {
                    "type"     : "random-pubsub-pair",
                    "time"     : 1,
                    "file"     : "/tmp/500KB",
                    "mutual_exclusive" : "true",
                    "number"   : 1
                }
            ]
        }

"pretty_name" <- this is the name that will show up in the "%%pretty_name%%".
"script" <- an array of objects specifying the pubs and subs.
"time" <- the what point in time in the emulation when the pub/sub occurs.
"type" <- "pub", "sub" or "random-pubsub-pair".
    "pub" : 
        "attributes" <- the attributes either in dictionary format { "k" : "v", ...},
        "node_num" <- which node will perform the pub 
or list format [ ("k", "v") ...] of the file being published
        "file" <- [optional] the file being published 
    "sub" :
        "attributes" <- same as attributes in "pub"
        "node_num" <- which node will perform the sub
        "duration" <- how long the sub will occur over
        "print_output" <- true/false: whether the recevied message from
haggletest should be included in "apps_output"
    "random-pubsub-pair" : used to dynamically generate a random source
destination pair (using a unique attribte). Uses the default seed.
        "file" <- [optional] the file being published
        "mutual_exclusive" <- true/false if any of sources and destinations can
be the same node. 
        "number" <- the number of pub/sub pairs to create. 

---

"uniform" :  Creates a steady stream of publications at a specific frequency, 
and subscriptions vary through time (with $K$ simultanous subscriptions, each
lasting a specified time at which point $K$ different subscriptions will be
picked). All of the nodes are creating and subscribing to content.


Example:

    "application_cfg"    : {
        "name" : "uniform",
        "parameters" : {
            "num_pub"            : 1,
            "pub_freq_s"         : 1,
            "sub_s"              : 15,
            "K"                  : 1
        }
    }

"num_pub" <- the total number of publications to perform.

"pub_freq_s" <- the inter-pub period in seconds.

"sub_s" <- the duration of the subscriptions, before clearing them and
selecting new subscriptions.

"K" <- the parallel subscription parameter. "K" subscriptions will occur
at each node.

----

"distribution_overlay" : allows an assortment of statistical distributions to
be overlayed. 

Example:

    "application_cfg"    : {
        "name" : "distribution_overlay",
        "parameters" : {
            "pub_distributions" : [
                {
                    "nodes" : [1, 2, 3, 4, 5, 6],
                    "delay_s"    : 1,
                    "duration_s" : 20,
                    "max_pubs" : 5,
                    "pub_num_attributes_distribution": {
                        "type" : "uniform_discrete",
                        "parameters" : {
                            "seed" : 3,
                            "elements" : [ 1, 2, 3, 4]
                        }
                    },
                    "pub_attributes_distribution" : {
                        "type" : "uniform_discrete",
                        "parameters" : {
                            "seed" : 5,
                            "elements" : [ [ "k1", "v1" ], [ "k2", "v2" ], [ "k3", "v3" ], [ "k4", "v4" ], [ [ "k7", "${NODE}" ], [ "k8", "${NOW}" ] ] ]
                        }
                    },
                    "pub_file_distribution" : {
                        "type" : "zipf_discrete",
                         "parameters" : {
                            "seed" : 1,
                            "elements_by_rank" : [ "/tmp/500KB", "", "/tmp/300KB", "/tmp/100KB", "/tmp/700KB", "/tmp/1MB", "/tmp/2MB" ],
                            "alpha" : 1.1
                        }
                    },
                    "inter_pub_delay_s_distribution" : {
                        "type"   : "exponential",
                        "parameters" : {
                            "seed" : 1,
                            "lam" :  0.2
                        }
                    }
                }
                ...
            ],
            "sub_distributions" : [ 
                {
                    "nodes" : [6, 7, 8, 9, 10, 11, 12],
                    "delay_s"    : 2,
                    "duration_s" : 20,
                    "max_subs" : 30,
                    "sub_num_attributes_distribution": {
                        "type" : "uniform_discrete",
                        "parameters" : {
                            "seed" : 1,
                            "elements" : [ 1, 2, 3 ]
                        }
                    },
                    "sub_attributes_distribution" : {
                        "type" : "zipf_discrete",
                        "parameters" : {
                            "seed" : 5,
                            "elements_by_rank" : [ [ "k5", "v5" ], [ "k1", "v1" ], [ "k2", "v2" ], [ "k3", "v3" ], [ "k4", "v4" ] ],
                            "alpha" : 1.1
                        }
                    },
                    "inter_sub_delay_s_distribution" : {
                        "type" : "uniform",
                        "parameters" : {
                            "seed" : 3,
                            "low"  : 1,
                            "high"  : 5
                        }
                    },
                    "sub_duration_s_distribution" : {
                        "type" : "normal",
                        "parameters" : {
                            "seed" : 1,
                            "mu"   : 6,
                            "std"  : 1
                        }
                    }
                }
            ]
        }
    }

"pub_distributions" <- an array of publication distributions for specific
nodes (you can have multiple distributions for the same node). 

    "nodes" <- the nodes to apply the publication distribution to
    "delay_s" <- how long to wait before publications start
    "duration_s" <- duration of the publications (no pub will occur after the
time has elapsed, starting from the delay_s. 
    "max_pubs" <- maximum number of publications (for each node)
    "pub_num_attributes_distribution" <- the number of attributes distribution.
Determines how many attributes each publication will have.
        "uniform_discrete" <- the number will be determined by selecting 
uniformly at random of a list of numbers. 
        "zipf_discrete" <- the number will be deteremined by selecting from
a ranked list of elements according to a zipf distribution with random 
"seed" and parameter "alpha".
    "pub_attributes_distribution" <-  the actual attribuets that each
data object will receive. 
        "uniform_discrete" <- an attribtue is selected (without replacement)
from the specified list of "elements", using the random "seed". Elements 
may be a list of elements, in which case multple attributes will be
selected with one selection. "${NODE}" is a variable that will contain
the publisher's name. ${NOW} is a variable that will contain the date at 
which point the test started (these are useful for specifying TTL caching
policies). 
        "zipf_discrete" <- an attribute is picked from a ranked list of
attributes (whose elements can be themselves a list of attributes) according
to a zipf distribution with random "seed" and zipf "alpha" parameter.
    "pub_file_distribution" <- the file that is being published. 
        "uniform_discrete" <- pick from a list of file names uniformly at 
random.
        "zipf_discrete" <- pick from a ranked list of file names according
to a zipf distribution. 
    "inter_pub_delay_s_distribution" <- determines that amount of delay (in
seconds) between subsequent publications at each node. 
        "exponential" <- an exponential distribution, with parameter "lam"
where 1/lam ~= expected inter-pub delay (in seconds).
        "uniform" <- uniform distribution in range ["low", "high"]
        "normal" <- gaussian distribution with mean "mu", stddev "std". 
    "sub_distributions" <- a list of subscription distributions (complements
the pub distributions).
        "nodes" <- which nodes the current distribution applies to.
        "delay_s" <- the amount of time to wait before the subscriptions
will commence. 
        "duration_s" <- no subscription will extend past 
delay_s + duration_s. 
        "max_subs" <- maximum number of subscriptions (per node basis).
        "sub_num_attributes_distribution" <- the number of attributes
that are being subscribed to (same parameters as the 
pub_num_attributs_distribution. 
        "sub_attributes_distribution" <- which attributes to subscribe to
(same parameters as pub_attributes_distribution).
        "inter_sub_delay_s_distribution" <- how long to wait in seconds between
issuing concurrent subscriptions (same parameters as the
inter_pub_delay_s_distribution).
        "sub_duration_s_distribution" <- the duration (in seconds) of the 
subscription (same parameters as the inter_sub_delay_s_distribution). 

====
MACPHY: We support CORE and EMANE mac/phy emulation and pass through the
specified options to the underlying emulator. 

We support multiple interfaces, where you specify which interfaces apply
to which nodes.

For example:

    "macphys_cfgs"       : [{
        "nodes": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12],
        "name" : "basic_range",
        "pretty_name" : "name to appear in %%pretty%%",
        "parameters" :  {
            "bandwidth_bps"      : 11000000,
            "range_radius_m"     : 250,
            "latency_us"         : 1000,
            "pkt_error_rate"     : 0.0
        }
    }
    ...
    ],

This specifies a "basic_range" configuration for ndoes 1-12, but subsequent
interfaces could also be specified in the list. 

----

"basic_range" <- The CORE basic MAC. Very idealized model without fading
and simplified errors. 
    "bandwidth_bps" <- the bandwidth in bits per second.
    "range_radius_m" <- the maixmum range in meters for communication.
    "latency_us" <- the latency in microseconds between communicating nodes.
    "pkt_error_rate" <- the packet error rate.

----

"emane_ieee80211abg" <- The EMANE MAC. A more realistic model for MAC/PHY
phenomena. Supports channel fading and more detailed errors.  

Example:

    "macphys_cfgs"       : [{
        "nodes": [1, 2],
        "name" : "emane_ieee80211abg",
        "pretty_name" : "pretty80211",
        "parameters": {
           "standard_mode"      : 3,
           "max_distance_m"     : 1000,
           "unicast_rate_mode"  : 9,
           "multicast_rate_mode"  : 9,
           "system_noise_figure" : "4",
           "antenna_gain_dbi"   : 3.02,
           "transmit_power_dbx" : 0,
           "antenna_type"       : "omnidirectional",
           "pathloss_mode"      : "freespace",
           "bandwidth_khz"      : 22000
        }
    }],

A full description of these parameters is outside the scope of this
document, and can be found in the CORE/EMANE documentation (we pass through
the parameter using the same names as those used in the CORE GUI configuration
of EMANE). In general, "unicast_rate_mode" and "multicast_rate_mode" control
the bandwidth, "system_noise_figure" the error, and "antenna_gain_dbi"
the range. 

====
SECURITY:

Add a "security_cfg" dictionary, which specifies Security configuration.

A config can over-ride the default top-level "security_cfg" by
having a "security_cfg" in its own section.

A full description of the available parameters is available in the
README-security-configuration-generator.txt file, in the JSON section.

Note that for Security configuration to work, haggleNodeIDTable.txt
must be present in the cases/framework/lxc/testgenerator directory. 
The haggleNodeIDs depend on the macphys_cfg for your test, 
so whenever that is changed or new nodes are added, 
this file must be updated. To generate this file,
go to setup/tools/security-haggle-node-id-generator, and
edit the test_spec.template to have your desired macphys_cfg,
being sure not to overwrite the %%ARRAY_STRING%% template.
Then generate and run the test, and then run make_id_list.sh with the
number of nodes, (e.g. for 30 nodes):

./make_id_list.sh 30

The script will automatically copy the haggleNodeIDTable to the
required destination path.

====
META-CHARACTERS:

We added some meta-characters to allow us to concisely specify many tests 
(for example, to repeat a test with different mobility seeds). These
characters begin with the "^" carrot, and replace a parameter with a
dictionary. For example, instead of

a : 2,

a meta-character would be:

a : { '^metachar' : parameters }, 

----

"^repeat" <- generate the same test, but vary a parameter across
all specified combinations. 

Example: 

....
    "mobility_cfg"       : {
        "^repeat" : [ 
            {
                "name" : "chain",
                "parameters" : {
                    "max_spacing_m" : 150
                }
            },
            {
                "name" : "clique"
            }
        ]
...

Generates the same test as wthout the ^repeat, but one instance with:

...
"mobility_cfg" : [
    {
        "name" : "chain",
        "parameters" : {
            "max_spacing_m" : 150
        }
    }
]
...

and another instance with:

...
"mobility_cfg" : [
    {
        "name" : "clique"
    }
]
...

Observe that a test file can have multiple repeats, and that they
can be nested (it will generate all the permutations).

----

"^assign" - (EXPERIMENTAL) assigns a specified value to a globally accessible
meta-variable. Wraps an existing parameter. This is useful when you
assign a value in a repeat which you then neeed to reference later in the
test (for example, perhaps you use the same repeated seed in multiple locations
in the test).

Example: 

originally you had a seed of 150:
    ...
    "seed" : 150,
    ...
but later in the test you want to reference this value, perhaps in a 
pretty name. Then you could do this as follows:

    ...
    "seed" : { "^assign" : 150,
                "%%custom_seed%%" : 150
            },
    ...
        "pretty_name" : "somestuff-%%custom_seed%%"
    ...
         

=====
EXPERIMENTAL/OPTIONAL FEATURES:

"neighbor_monitor" : {
    "enable_neighbor_monitor" : "true",
    "neighbor_monitor_max_latency_ms" : 40,
    "neighbor_monitor_period_s" : 1
} <- [optional] / experimental feature to keep track of the connectivity
graph while the test is running. We do not recommend this setting is used
in production. If this is set to "true", the output test directory 
(created by testrunner) will contain a file "neighbors.gexf" which can be
open in the Gephi graph editor, and will display the connectivity as
detected by ping and the arp table. 
    "enable_neighbor_monitor" <- true/false to enable/disable this feature.
    "neighbor_monitor_max_latency_ms" : <- maximum number of ms to wait
for a ping reply in order to detect a neighbor.
    "neighbor_monitor_period_s" :  <- number of seconds to poll the arp table
looking for new neighbors. 


"observer" : {
    "enable_observer": "true",
    "attribute_name": "ObserverDataObjectOrigin",
    "attribute_value": "${NODE_NAME}"
} <- [optional] / experimental feature to keep track of the haggle metrics
graph while the test is running. W If this is set to "true", the output test directory 
(created by testrunner) will contain a file "haggleobserver.log" per node which can be
    "enable_observer" <- true/false to enable/disable this feature.
    "attribute_name" <- the attribute to subscribe to
    "attribute_value" <- the value of the attribute to subscribe to

